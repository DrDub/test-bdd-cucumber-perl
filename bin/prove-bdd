#!perl

use strict;
use warnings;
use FindBin::libs;

use Ouch;
use Method::Signatures;
use Test::BDD::Cucumber::Parser;
use Test::BDD::Cucumber::Executor;
use Test::BDD::Cucumber::Harness;
use Test::More;

my $feature = eval { Test::BDD::Cucumber::Parser->parse_file(
	't/fsets/parser/feature_parser.feature' ) };

if ( hug ) {
	warn $@->scalar;
	warn $@->data->debug_summary;
	die;
}

my $executor = Test::BDD::Cucumber::Executor->new();

$executor->add_steps(
    [ given => 'a feature parser' => func ($c) {} ],
    [ given => 'the following text is parsed', func ($c) {
        die "Only accepts a string" if ref $c->data;

        # Attempt to parse
        my $test_feature = eval { Test::BDD::Cucumber::Parser->parse_string(
            $c->data ) };

        # Handle-able error
        if ( ref($@) && $@->isa('Ouch') ) {
            $c->stash->{'scenario'}->{'error'} = $@;
        } elsif ( $@ ) {
            die $@;
        }

        # Save the output
        $c->stash->{'scenario'}->{'feature'} = $test_feature;

    } ],
    [ then => 'there should be no parse errors' => func ($c) {
        ok( !$c->stash->{'scenario'}->{'errors'}, "No errors" ) ||
            diag( $@->debug_summary );
    } ],
    [ then => qr/there should be parse errors on .+? (\d+)/ => func ($c) {
        my $error = $c->stash->{'scenario'}->{'error'};
        ok( $error, "Error is present" ) || return;
        is( $error->code, 'parse_error', "Correct error code" ) || return;
        is( $error->data->number, $c->matches->[0],
            "Error is on the right line" );
    } ],
);

my $harness = Test::BDD::Cucumber::Harness->new();
$executor->execute( $feature, $harness );

